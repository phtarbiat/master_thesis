//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: feedbackLinearization_rigid_model.cpp
//
// MATLAB Coder version            : 5.4
// C/C++ source code generated on  : 19-Feb-2023 09:34:48
//

// Include Files
#include "feedbackLinearization_rigid_model.h"
#include "feedbackLinearization_rigid_model_types.h"
#include <cmath>

// Function Definitions
//
// Computed-Torque feedback linearization for the rigid body model
//
//  Philipp Tarbiat
//  Chair of Automatic Control
//  TUM School of Engineering and Design
//  Technical University of Munich
//
// Arguments    : const struct0_T *paramStruct
//                const double theta_des_k[3]
//                const double omega_des_k[3]
//                const double domega_des_k[3]
//                const double theta_k[3]
//                const double omega_k[3]
//                double u_k[3]
// Return Type  : void
//
void feedbackLinearization_rigid_model(const struct0_T *paramStruct,
                                       const double theta_des_k[3],
                                       const double omega_des_k[3],
                                       const double domega_des_k[3],
                                       const double theta_k[3],
                                       const double omega_k[3], double u_k[3])
{
  double b_u_k_tmp;
  double c_u_k_tmp;
  double d_u_k_tmp;
  double e_u_k_tmp;
  double f_u_k_tmp;
  double g_u_k_tmp;
  double h_u_k_tmp;
  double i_u_k_tmp;
  double j_u_k_tmp;
  double k_u_k_tmp;
  double l_u_k_tmp;
  double t10;
  double t11;
  double t14;
  double t16;
  double t17;
  double t19;
  double t2;
  double t20;
  double t21;
  double t27;
  double t28;
  double t3;
  double t30;
  double t31;
  double t34;
  double t35;
  double t36;
  double t4;
  double t44;
  double t45;
  double t5;
  double t53;
  double t54;
  double t56;
  double t57;
  double t6;
  double t62;
  double t64;
  double t7;
  double t70;
  double t73;
  double t74;
  double t77;
  double t8;
  double u_k_tmp;
  double v_k_idx_0;
  double v_k_idx_1;
  double v_k_idx_2;
  //  Load model parameters
  //  Robot model
  //  Feedback linearization
  //  Calculate v
  v_k_idx_0 =
      (paramStruct->controller.k_theta[0] * (theta_des_k[0] - theta_k[0]) +
       paramStruct->controller.k_omega[0] * (omega_des_k[0] - omega_k[0])) +
      domega_des_k[0];
  v_k_idx_1 =
      (paramStruct->controller.k_theta[1] * (theta_des_k[1] - theta_k[1]) +
       paramStruct->controller.k_omega[1] * (omega_des_k[1] - omega_k[1])) +
      domega_des_k[1];
  v_k_idx_2 =
      (paramStruct->controller.k_theta[2] * (theta_des_k[2] - theta_k[2]) +
       paramStruct->controller.k_omega[2] * (omega_des_k[2] - omega_k[2])) +
      domega_des_k[2];
  //  Calculate control output
  // feedbackLinearization_rigid_fun
  //     U = feedbackLinearization_rigid_fun(G,IN2,IN3,IN4,IN5,IN6,IN7,IN8)
  //     This function was generated by the Symbolic Math Toolbox version 9.1.
  //     11-Jan-2023 09:46:35
  //  Code generated by file 'LiveEditorEvaluationHelperE1455415238'.
  //  Model: feedbackLinearization_rigid_fun
  //  Inputs: g, r_P1P2, r_P2P3, r_P3P4, baseParam, theta, omega, v
  //
  t2 = std::cos(theta_k[1]);
  t3 = std::cos(theta_k[2]);
  t4 = std::sin(theta_k[1]);
  t5 = std::sin(theta_k[2]);
  t6 = omega_k[1] + omega_k[2];
  t7 = theta_k[1] + theta_k[2];
  t8 = theta_k[1] * 2.0;
  t10 = std::cos(t8);
  t11 = std::sin(t8);
  t14 = paramStruct->robot.r_P2P3[0] * t3;
  t16 = paramStruct->robot.r_P2P3[1] * t3;
  t17 = std::cos(t7);
  t19 = paramStruct->robot.r_P2P3[0] * t5;
  t20 = paramStruct->robot.r_P2P3[1] * t5;
  t21 = std::sin(t7);
  t8 = t7 + theta_k[1];
  t5 = paramStruct->robot.r_P1P2[1] + -paramStruct->robot.r_P2P3[2];
  t3 = t7 * 2.0;
  t27 = std::cos(t8);
  t28 = std::sin(t8);
  t30 = omega_k[1] * t17;
  t31 = omega_k[2] * t17;
  t34 = omega_k[1] * t21;
  t35 = omega_k[2] * t21;
  t36 = paramStruct->robot.r_P1P2[0] * t21;
  t53 = std::cos(t3);
  t54 = std::sin(t3);
  t56 = t17 * -paramStruct->robot.r_P1P2[0];
  t57 = t14 + t20;
  t70 =
      (paramStruct->robot.r_P2P3[1] * t2 + paramStruct->robot.r_P2P3[0] * t4) +
      -paramStruct->robot.r_P1P2[0];
  t44 = paramStruct->robot.r_P1P2[1] * t30;
  t45 = paramStruct->robot.r_P1P2[1] * t31;
  t62 = paramStruct->robot.baseParam[15] * t57;
  t8 = omega_k[0] * paramStruct->robot.baseParam[11] * t53;
  t64 = t16 + -t19;
  t3 = omega_k[0] * paramStruct->robot.baseParam[10] * t54 / 2.0;
  t73 = paramStruct->robot.baseParam[13] * (t30 + t31);
  t74 = paramStruct->robot.baseParam[12] * (t34 + t35);
  t5 = ((paramStruct->robot.baseParam[12] * t17 +
         -(paramStruct->robot.baseParam[13] * t21)) +
        paramStruct->robot.baseParam[15] * t17 * t5) +
       -(paramStruct->robot.baseParam[16] * t21 * t5);
  t7 = (paramStruct->robot.baseParam[14] + t62) +
       paramStruct->robot.baseParam[16] * t64;
  t77 =
      (((paramStruct->robot.baseParam[4] * t2 +
         paramStruct->robot.r_P1P2[1] * paramStruct->robot.baseParam[7] * t2) +
        -(paramStruct->robot.baseParam[5] * t4)) +
       -(paramStruct->robot.r_P1P2[1] * paramStruct->robot.baseParam[8] * t4)) +
      t5;
  u_k_tmp = paramStruct->robot.r_P2P3[0] * omega_k[1];
  b_u_k_tmp = paramStruct->robot.r_P2P3[0] * omega_k[2];
  c_u_k_tmp = omega_k[1] * paramStruct->robot.r_P2P3[1];
  d_u_k_tmp = paramStruct->robot.r_P2P3[1] * omega_k[2];
  e_u_k_tmp = omega_k[0] * paramStruct->robot.r_P2P3[0];
  f_u_k_tmp = omega_k[0] * paramStruct->robot.r_P2P3[1];
  g_u_k_tmp = omega_k[0] * paramStruct->robot.r_P1P2[0];
  h_u_k_tmp = omega_k[1] * paramStruct->robot.r_P1P2[1];
  i_u_k_tmp = e_u_k_tmp * t27;
  j_u_k_tmp = f_u_k_tmp * t28;
  k_u_k_tmp = (((paramStruct->robot.r_P2P3[2] * t34 +
                 paramStruct->robot.r_P2P3[2] * t35) +
                omega_k[0] * t56) +
               -(paramStruct->robot.r_P1P2[1] * t34)) +
              -(paramStruct->robot.r_P1P2[1] * t35);
  e_u_k_tmp *= t28;
  f_u_k_tmp *= t27;
  l_u_k_tmp = ((omega_k[0] * paramStruct->robot.baseParam[3] * t10 +
                omega_k[0] * paramStruct->robot.baseParam[2] * t11 / 2.0) +
               t8) +
              t3;
  t8 += t3;
  u_k[0] =
      (((-omega_k[0] *
             (((((((-paramStruct->robot.baseParam[15] *
                        (((((((omega_k[2] * t16 / 2.0 -
                               omega_k[2] * t19 / 2.0) +
                              -paramStruct->robot.r_P1P2[0] * t30) +
                             -paramStruct->robot.r_P1P2[0] * t31) +
                            u_k_tmp * t28) +
                           c_u_k_tmp * t27) +
                          b_u_k_tmp * t28 / 2.0) +
                         d_u_k_tmp * t27 / 2.0) +
                    paramStruct->robot.baseParam[16] *
                        (((((((omega_k[2] * t14 / 2.0 +
                               omega_k[2] * t20 / 2.0) +
                              -paramStruct->robot.r_P1P2[0] * t34) +
                             -paramStruct->robot.r_P1P2[0] * t35) -
                            u_k_tmp * t27) -
                           b_u_k_tmp * t27 / 2.0) +
                          c_u_k_tmp * t28) +
                         d_u_k_tmp * t28 / 2.0)) +
                   paramStruct->robot.baseParam[11] *
                       (omega_k[1] * t53 + omega_k[2] * t53)) +
                  paramStruct->robot.baseParam[10] *
                      (omega_k[1] * t54 / 2.0 + omega_k[2] * t54 / 2.0)) +
                 omega_k[1] * paramStruct->robot.baseParam[2] * t11 / 2.0) +
                omega_k[1] * paramStruct->robot.baseParam[3] * t10) +
               omega_k[1] * paramStruct->robot.baseParam[7] *
                   paramStruct->robot.r_P1P2[0] * t2) +
              omega_k[1] * paramStruct->robot.baseParam[8] * t4 *
                  -paramStruct->robot.r_P1P2[0]) +
         t5 * v_k_idx_2) +
        t77 * v_k_idx_1) +
       (-omega_k[2] *
            ((((t8 + t73) + t74) +
              paramStruct->robot.baseParam[16] *
                  ((((((((t44 + t45) + omega_k[0] * t14 / 2.0) +
                        omega_k[0] * t20 / 2.0) +
                       -paramStruct->robot.r_P2P3[2] * t30) +
                      -paramStruct->robot.r_P2P3[2] * t31) -
                     i_u_k_tmp / 2.0) +
                    j_u_k_tmp / 2.0) +
                   omega_k[0] * t21 * -paramStruct->robot.r_P1P2[0])) -
             paramStruct->robot.baseParam[15] *
                 ((((k_u_k_tmp + omega_k[0] * t16 / 2.0) -
                    omega_k[0] * t19 / 2.0) +
                   e_u_k_tmp / 2.0) +
                  f_u_k_tmp / 2.0)) -
        omega_k[1] *
            ((((((((l_u_k_tmp + t73) + t74) +
                  paramStruct->robot.baseParam[7] *
                      (g_u_k_tmp * t2 + h_u_k_tmp * t4)) -
                 paramStruct->robot.baseParam[8] *
                     (g_u_k_tmp * t4 - h_u_k_tmp * t2)) -
                paramStruct->robot.baseParam[16] *
                    ((((((-t44 - t45) + paramStruct->robot.r_P2P3[2] * t30) +
                        paramStruct->robot.r_P2P3[2] * t31) +
                       omega_k[0] * t36) +
                      i_u_k_tmp) -
                     j_u_k_tmp)) -
               paramStruct->robot.baseParam[15] *
                   ((k_u_k_tmp + e_u_k_tmp) + f_u_k_tmp)) +
              omega_k[1] * paramStruct->robot.baseParam[5] * t2) +
             omega_k[1] * paramStruct->robot.baseParam[4] * t4))) +
      v_k_idx_0 * ((((((((paramStruct->robot.baseParam[0] +
                          paramStruct->robot.baseParam[2] * (t2 * t2)) +
                         paramStruct->robot.baseParam[10] * (t17 * t17)) -
                        paramStruct->robot.r_P1P2[0] *
                            paramStruct->robot.baseParam[8] * t2 * 2.0) -
                       paramStruct->robot.r_P1P2[0] *
                           paramStruct->robot.baseParam[7] * t4 * 2.0) -
                      paramStruct->robot.baseParam[3] * t2 * t4 * 2.0) -
                     paramStruct->robot.baseParam[11] * t17 * t21 * 2.0) +
                    paramStruct->robot.baseParam[16] * t17 * t70 * 2.0) +
                   paramStruct->robot.baseParam[15] * t21 * t70 * 2.0);
  u_k_tmp = paramStruct->robot.r_P2P3[0] * t27;
  b_u_k_tmp = paramStruct->robot.r_P2P3[1] * t28;
  c_u_k_tmp = omega_k[0] * paramStruct->robot.baseParam[16];
  d_u_k_tmp = paramStruct->robot.r_P2P3[0] * t28;
  e_u_k_tmp = paramStruct->robot.r_P2P3[1] * t27;
  f_u_k_tmp = omega_k[0] * paramStruct->robot.baseParam[15];
  u_k[1] =
      ((((t7 * v_k_idx_2 + t77 * v_k_idx_0) +
         omega_k[0] *
             ((((l_u_k_tmp - c_u_k_tmp * ((t36 + u_k_tmp) - b_u_k_tmp)) -
                f_u_k_tmp * ((t56 + d_u_k_tmp) + e_u_k_tmp)) +
               omega_k[0] * paramStruct->robot.baseParam[7] *
                   paramStruct->robot.r_P1P2[0] * t2) +
              omega_k[0] * paramStruct->robot.baseParam[8] * t4 *
                  -paramStruct->robot.r_P1P2[0])) -
        omega_k[1] * (omega_k[2] * paramStruct->robot.baseParam[16] * t57 -
                      omega_k[2] * paramStruct->robot.baseParam[15] * t64)) -
       omega_k[2] * (paramStruct->robot.baseParam[16] * t6 * t57 -
                     paramStruct->robot.baseParam[15] * t6 * t64)) +
      v_k_idx_1 * (((paramStruct->robot.baseParam[6] +
                     paramStruct->robot.baseParam[14]) +
                    t62 * 2.0) +
                   paramStruct->robot.baseParam[16] * (t16 * 2.0 - t19 * 2.0));
  u_k[2] =
      (((v_k_idx_2 * paramStruct->robot.baseParam[14] + t7 * v_k_idx_1) +
        t5 * v_k_idx_0) +
       omega_k[0] *
           ((t8 + c_u_k_tmp * ((((t14 / 2.0 + t20 / 2.0) - u_k_tmp / 2.0) +
                                b_u_k_tmp / 2.0) +
                               t21 * -paramStruct->robot.r_P1P2[0])) -
            f_u_k_tmp * ((((t16 / 2.0 - t19 / 2.0) + t56) + d_u_k_tmp / 2.0) +
                         e_u_k_tmp / 2.0))) +
      omega_k[1] * (omega_k[1] * paramStruct->robot.baseParam[16] * t57 -
                    omega_k[1] * paramStruct->robot.baseParam[15] * t64);
}

//
// Arguments    : void
// Return Type  : void
//
void feedbackLinearization_rigid_model_initialize()
{
}

//
// Arguments    : void
// Return Type  : void
//
void feedbackLinearization_rigid_model_terminate()
{
}

//
// File trailer for feedbackLinearization_rigid_model.cpp
//
// [EOF]
//
